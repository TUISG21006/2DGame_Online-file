<!DOCTYPE html>
<html>
<head>
<title>テスト</title>
</head>
<canvas id="view" width = "720px" height = "480px"></canvas>
<script src="socket.io/socket.io.js"></script>
<body>
<script type="text/javascript">
//memo
//アイテムの取得関数はmove関数の中にあります。

//サーバとの接続
var socket = io.connect();
//ドキュメント要素の取得
var canvas = document.getElementById('view');
//canvasに描画するコンテキストを取得
var ctx = canvas.getContext('2d');

//サーバからのデータを受け流す変数
let init_data,map_init;

let startTime = performance.now();
let endTime = performance.now(); 

//init用変数
let user1_setx,user1_sety,sizeh,sizew,ava_type,fps,block_size,max_spead,jump_pow,rotation,friction,gravity,max_move,keycode_up,keycode_do,keycode_le,keycode_ri,map;;
//アバタの変数（改善の余地あり）
let ava_x,ava_y,ava2_x,ava2_y,angle1,jump1,acsell1,up_flag,do_flag,le_flag,ri_flag,limit_time;

let Genre,user_collision,synchro_frec,item_size;;
let user_number;
let set_x,set_y;

let score = 0;

let item_list = [];
let level = 1;
let maxscore = 0;
let win = true;
let sin = 1;
//サーバから送られた情報での初期設定
const init = function(){
    console.log("init");

    Genre = init_data.Genre
    user_collision = init_data.user_collision;
    synchro_frec = init_data.synchro_frec;
    item_size = init_data.item_size;


    user1_setx = init_data.user1_setx;
    user1_sety = init_data.user1_sety;

    user1_setx = init_data.user_setx;
    user1_sety = init_data.user_sety;

    sizeh = init_data.sizeh;//アバタのサイズ
    sizew = init_data.sizew;//アバタのサイズ
    ava_type = init_data.ava_type;//アバタの外見

    fps = init_data.fps;//画面更新頻度

    block_size = init_data.block_size;//ブロックのサイズ

    limit_time = init_data.limit_time;//時間制限

    max_spead = init_data.max_spead;//レース操作時最大速度

    jump_pow = init_data.jump_pow;//最大ジャンプ力
    rotation = init_data.rotation;//回転速度

    friction = init_data.friction;//摩擦係数
    gravity = init_data.gravity;//重力

    //秒間の最高速度
    max_move = init_data.max_move;

    keycode_up = init_data.keycode_up;
    keycode_do = init_data.keycode_do;
    keycode_le = init_data.keycode_le;
    keycode_ri = init_data.keycode_ri;

    map = map_init.map;
}

//アバタの初期配置
const initial_position = function(){
    console.log("initial_position");
    set_x = user1_setx;
    set_y = user1_sety;
}

//ゲーム内変数
let Ingame_parameters =function(){
    console.log("Ingame_parameters");
    ava_x = set_x;
    ava_y = set_y;
    angle1 = 0;

    jump1 = 1.0;
    acsell1 = 0.0;

    //動いている状態
    up_flag = false;
    do_flag = false;
    le_flag = false;
    ri_flag = false;
}

//rotation + potato この変数に意味はない
const rotato = null;

//自キャラ作画用変数
let chara;
let other_chara;
let avater_list = [];

//自キャラ登録用関数（アバタの画像、サイズ横、サイズ縦、初期位置x、初期位置y）
//登録後は「chara(座標x,座標y)」でアバタを描画
let chara_set = function(type = 0,wide = 10,hight = 10,x = 0,y = 0){
    if(type == 0){
        chara = function(x,y,angle){
            ctx.save();
            ctx.translate(x + wide / 2, y + hight / 2);
            ctx.rotate(angle1);
            ctx.translate(-x - wide / 2,-y - hight / 2);
            ctx.font = acsell1*wide/3+"px serif";
            ctx.fillText("↑", x + wide/2 - acsell1*5,y);
            ctx.strokeRect(x,y,wide,hight);
            ctx.restore();
        }
    }
    else{
        chara = function(x,y,angle){
            ctx.save();
            ctx.translate(x + wide / 2, y + hight / 2);
            ctx.rotate(angle);
            ctx.translate(-x - wide / 2,-y - hight / 2);
            ctx.drawImage(type,x,y,wide,hight)
            ctx.restore();
        }
    }
}

//他ユーザ描画用
let other_chara_set = function(type = 0,wide = 10,hight = 10,x = 0,y = 0){
    if(type == 0){
        other_chara = function(x,y,angle){
            ctx.save();
            ctx.translate(x + wide / 2, y + hight / 2);
            ctx.rotate(angle);
            ctx.translate(-x - wide / 2,-y - hight / 2);
            ctx.strokeRect(x,y,wide,hight);
            ctx.restore();
        }
    }
    else{
        chara = function(x,y,angle){
            ctx.save();
            ctx.translate(x + wide / 2, y + hight / 2);
            ctx.rotate(angle);
            ctx.translate(-x - wide / 2,-y - hight / 2);
            ctx.drawImage(type,x,y,wide,hight)
            ctx.restore();
        }
    }
}

//カウントダウン用。嘘だと思うでしょうがreturn num--;では動かないのです。
let count_down = function(num){
    num--;
    return num;
}

let point_update = function(x,y,angle,jump,acsell){
    ava_x = x;
    ava_y = y;
    angle1 = angle;
    jump1 = jump;
    acsell1 = acsell;
}

//画面描画用関数（流用性はかなり低い:変数ava_x,ava_y,angle）
let drow = function(){
    //画面削除
    ctx.clearRect(0, 0,800,480);
    ctx.beginPath();

    ctx.fillStyle = "#000000";
    ctx.fillText(limit_time,500,200);
    //自アバタ描画
    chara(ava_x,ava_y,angle1);
    

    //アバタ描画
    for(var i = 0;i < avater_list.length;i++){
        if(avater_list[i] != undefined){
            other_chara(avater_list[i].x,avater_list[i].y,avater_list[i].angle);
        }
    }

    //ステージブロックの描画
    for(var i = 0;i < map.length;i++){
        for(let j = 0;j < map[i].length;j++){
            if(map[i][j] == 1)
            ctx.fillRect(j*block_size,i*block_size,block_size,block_size);
        }
    }

    //アイテムオブジェクトの描画
    ctx.fillStyle = "#FFA500";
    for(var j = 0;j<item_list.length;j++){
        if(item_list[j].get == false){
            ctx.fillRect(item_list[j].x,item_list[j].y,item_size,item_size);
        }
    }
}

//動作用関数（可読性はかなり低い）
let move = function(Genre,x,y,angle,up,down,left,right,jump,acsell,user){
    //変数更新用変数
    var new_x = x;
    var new_y = y;
    var new_angle = angle;

    //ジャンプ更新用変数
    var new_jump = jump;

    //角度更新用変数
    var new_angle = angle;
    var new_acsell = acsell;

    //アクションゲーム時の動作
    if(Genre == 1){
        //上キー入力時&上進行可能時
        //この辺上下左右使いまわしなので関数に使用としたがスパゲッティ化しそうなので却下
        //解説は落下処理箇所に記載
        if(upper_collision(x,y,sizew,sizeh) && up){
            //アバター同士に接触判定があり接触を行った際
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !upper_avatar_collision(x,y,user[i].x,user[i].y,sizeh)){
                            new_jump = 0;
                            break check;
                        }
                    }
                    new_jump = jump - jump_pow;
                    new_y--;
                    break check;
                }
            }
            else{
                new_jump = jump - jump_pow;
                new_y--;
            }
        }
        //下キー入力時
        if(under_collision(x,y,sizew,sizeh) && down){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !under_avatar_collision(x,y,user[i].x,user[i].y,sizeh)){
                            new_jump = 0;
                            break check;
                        }
                    }
                    new_y++;
                    break check;
                }
            }
            else{
                new_y++;
            }
        }
        //右キー入力時
        if(left_collision(x,y,sizew,sizeh) && left){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !left_avatar_collision(x,y,user[i],x,user[i],y,sizeh)){
                            break check;
                        }
                    }
                    new_x--;
                    break check;
                }
            }
            else{
                new_x--;
            }
        }
        //左キー入力時
        if(right_collision(x,y,sizew,sizeh )&& right){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !right_avatar_collision(x,y,user[i],x,user[i],y,sizeh)){
                            break check;
                        }
                    }
                    new_x++;
                    break check;
                }
            }
            else{
                new_x++;
            }
        }

        //落ちる処理（床にめり込んだ際はフィールドに戻す）
        if(under_collision(x,y,sizew,sizeh)){
            new_jump += gravity;
            //他アバタと接触がある際の動作
            if(user_collision == 1&&user.length>0){
                //一度でも他ユーザと接触があればcheckを切る
                check : while(true){
                    for(var i = 1;i < user.length;i++){
                        if(user[i] != undefined && !under_avatar_collision(x,y,user[i].x,user[i].y,sizeh)){
                            new_y = Math.ceil(y-1);
                            new_jump = 0;
                            break check;
                        }
                    }
                    //一度も他ユーザと接触が無ければ落下しcheckを切る
                    new_y += new_jump;
                    break check;
                }
            }
            else{
                new_y += new_jump;
            }
        }
        //床接着時
        else{
            new_jump = 0;
            new_y = Math.ceil(y-1);
        }
        //飛び上がる処理（天井にめり込んだ際は戻す）
        if(!upper_collision(x,y,sizew,sizeh)){new_jump = 0;new_y = Math.ceil(y+1);}
    }

    //シューティング時の動作
    if(Genre == 2){
        if(upper_collision(x,y,sizew,sizeh) && up){
            //アバター同士に接触判定があり接触を行った際
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !upper_avatar_collision(x,y,user[i].x,user[i].y,sizeh)){
                            break check;
                        }
                    }
                    new_y--;
                    break check;
                }
            }
            else{
                new_y--;
            }
        }

        if(under_collision(x,y,sizew,sizeh) && down){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !under_avatar_collision(x,y,user[i].x,user[i].y,sizeh)){
                            break check;
                        }
                    }
                    new_y++;
                    break check;
                }
            }
            else{
                new_y++;
            }
        }
        
        if(left_collision(x,y,sizew,sizeh) && left){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !left_avatar_collision(x,y,user[i],x,user[i],y,sizeh)){
                            break check;
                        }
                    }
                    new_x--;
                    break check;
                }
            }
            else{
                new_x--;
            }
        }
        if(right_collision(x,y,sizew,sizeh) && right){
            if(user_collision == 1&&user.length>0){
                check : while(true){
                    for(var i = 1;i< user.length;i++){
                        if(user[i] != undefined && !right_avatar_collision(x,y,user[i],x,user[i],y,sizeh)){
                            break check;
                        }
                    }
                    new_x++;
                    break check;
                }
            }
            else{
                new_x++;
            }
        }
    }

    //レースゲーム時の動作
    if(Genre == 3){
        //0:sin=0,cos=1 90:sin=1,cos=0 180:sin=0,cos=-1 270:sin=-1,cos=0
        
        //上下の進行
        if((Math.cos(angle) >= 0 && upper_collision(x,y,sizew,sizeh))
        ||(Math.cos(angle) < 0 && under_collision(x,y,sizew,sizeh))){
            new_y -= acsell * Math.cos(angle);
        }

        //左右の進行
        if((Math.sin(angle) >= 0 && right_collision(x,y,sizew,sizeh))||
        (Math.sin(angle) < 0 && left_collision(x,y,sizew,sizeh))){
            new_x += acsell * Math.sin(angle);   
        }

        //上キーで加速
        if(up){
            if(acsell < max_spead)new_acsell += 0.01;
        }

        //非加速時は減速
        else{
            if(acsell > 0 && friction > 0){new_acsell -= 1*friction;}
            else if(acsell > 0 && friction == 0){new_acsell = acsell}
            else{acsell = 0}
        }
        
        //角度の更新
        if(left){new_angle -=  rotation;}
        if(right){new_angle += rotation;}
    }
    

    for(var i = 0;i < item_list.length;i++){
        if(item_list[i].get == false && item_collision(x+sizew/4,y+sizew/4,item_list[i].x,item_list[i].y,sizew,item_size)){
            score++;
            console.log(score);
            item_list[i].get = true;
            socket.emit('Item_get',i);
        }
    }

    //ユーザ情報の更新処理
    point_update(new_x,new_y,new_angle,new_jump,new_acsell);

    //情報更新の送信
    socket.emit("Avater_move",new_x,new_y,new_angle,user_number);

};

//上側の通過判定関数
let upper_collision = function(x,y,sw,sh){
    if(map[Math.floor((y-1)/block_size)][Math.floor((x)/block_size)]==1
    ||map[Math.floor((y-1)/block_size)][Math.ceil((x)/block_size)]==1){
        return false;
    }
    else{
        return true;
    }
}

//下側の通過判定関数
let under_collision = function(x,y,sw,sh){
    if(map[Math.floor((y+sh+1)/block_size)][Math.floor((x)/block_size)]==1
    ||map[Math.floor((y+sh+1)/block_size)][Math.ceil((x)/block_size)]==1){
        return false;
    }
    else{
        return true;
    }
}

//左側の通過判定関数
let left_collision = function(x,y,sw,sh){
    if(map[Math.floor((y)/block_size)][Math.floor((x-1)/block_size)]==1||map[Math.ceil((y)/block_size)][Math.floor((x-1)/block_size)]==1){return false;}
    else{return true;}
}

//右側の通過判定関数
let right_collision = function(x,y,sw,sh){
    if(map[Math.floor((y)/block_size)][Math.floor((x+sw)/block_size)]==1||map[Math.ceil((y)/block_size)][Math.floor((x+sw)/block_size)]==1){return false;}
    else{return true;}
}

//上側ユーザ接触
let upper_avatar_collision = function(x,y,ex,ey,hight){
    if(Math.abs(y-ey)< hight && y-ey > 0 && Math.abs(x-ex)<hight){
        return false;
    }
    else{
        return true;
    }
};

//下側ユーザ接触
let under_avatar_collision = function(x,y,ex,ey,hight){
    if(Math.abs(y-ey)< hight && y-ey <= 0 && Math.abs(x-ex)<hight){
        return false;
    }
    else{
        return true;
    }
};

//左側ユーザ接触
let left_avatar_collision = function(x,y,ex,ey,wide){
    if(Math.abs(x-ex)< wide && x-ex >= 0 && Math.abs(y-ey)<wide){
        return false;
    }
    else{
        return true;
    }
};

//右側ユーザ接触
let right_avatar_collision = function(x,y,ex,ey,wide){
    if(Math.abs(x-ex)< wide && x-ex < 0 && Math.abs(y-ey)<wide){
        return false;
    }
    else{
        return true;
    }
};

//アイテムの接触判定（アイテムは座標間の距離で測っているので上下左右はない）
let item_collision = function(x,y,ix,iy,size,isize){
    if(Math.abs(ix - x) + Math.abs(iy - y) < (size + isize) / 2){
        return true;
    }
};

//キーボード操作関数
document.onkeydown = function (e) {
    if(e.key == keycode_up)up_flag = true;
    if(e.key == keycode_do)do_flag = true;
    if(e.key == keycode_le)le_flag = true;
    if(e.key == keycode_ri)ri_flag = true;
}
document.onkeyup = function(e){
    if(e.key == keycode_up)up_flag = false;
    if(e.key == keycode_do)do_flag = false;
    if(e.key == keycode_le)le_flag = false;
    if(e.key == keycode_ri)ri_flag = false;
}

let main = function(){
    chara_set(ava_type,sizew,sizew,set_x,set_y);
    other_chara_set(ava_type,sizew,sizew,set_x,set_y);

    //画面更新処理
    var Ain = setInterval(function(){
        drow();
    },1000/fps)

    //座標更新処理
    var Soph = setInterval(function(){
        startTime = performance.now();
        move(Genre,ava_x,ava_y,angle1,up_flag,do_flag,le_flag,ri_flag,jump1,acsell1,avater_list);
        endTime = performance.now(); 
        //console.log(startTime-endTime);
    },1000/max_move)

    //時間管理処理
    var Aur = setInterval(function(){
        if(limit_time > 0){
            limit_time = count_down(limit_time);
        }else{
            clearInterval(Ain);
            clearInterval(Soph);
            clearInterval(Aur);
            clearInterval(Synchro);
            Game_end_func();
        }
    },1000);
    
    //同期処理（親クライアント
    var Synchro = setInterval(function(){
        if(level == 1)socket.emit("Client_Synchoro",limit_time,item_list)
    },1000/synchro_frec);
}

//ゲーム終了時処理
let Game_end_func = function(){
    socket.emit('Battle_Synchoro',score)
    setTimeout(function(){
        if(win ==true)alert("YOUWIN SCORE:" + score);
        else alert('YOULOSE HIGHT SCORE:' + maxscore + '\n' + "YOU:" + score);
    },5000)

}

//他ユーザから受信した情報
socket.on("Avater_move",function(sx,sy,sangle,num){
    avater_list[num] = {x:sx,y:sy,angle:sangle}
})

//アイテムを他のユーザが取得した
socket.on("Item_get",function(i){
    item_list[i].get = true;
})

//親クライアントを定義し子クライアントは時間、アイテムの情報を同期する
socket.on("Client_Synchoro",function(time,item){
    if(init_data != undefined){
        if(limit_time >= init_data.limit_time-1){
            level = 0;
            item_list = item;
            console.log('Your 0');
        }
        if(level == 0){
            limit_time = time;
        }
    }
})

//スコア型での勝利条件
socket.on("Battle_Synchoro",function(i){
    if(score <= i){
        maxscore = i;
        win = false;
    }
})

//他ユーザがログアウトした
socket.on("disconnect",function(num){
    avater_list.splice(num);
})

//初期の同期
socket.on("Initial_setting",function(initData,mapData,number,item){
    console.log("get_Data");
    init_data = initData;
    map_init = mapData;
    user_number = number;
    item_list = item;
    setTimeout(init,0)
    setTimeout(initial_position,1)
    setTimeout(Ingame_parameters,3)
    setTimeout(main,10)
});
socket.emit("room_in");

</script>
</body>
</html>